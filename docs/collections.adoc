include::./.asciidoctor/.asciidoctorconfig[]

=== Сравнение перечисляемых типов

|===
|_Критерий сравнения_|typle |list |set

|_Нотация_
|a = (1, 2, 3)
|b = [1, 2, 3]
|c = {1, 2, 3}

|_Название_
|Кортеж
|Список
|Множество

|_Хэшируем_
|+
|-
|-

|_Упорядоченность_
|Всегда упорядоченный список объектов
|Всегда упорядоченный список объектов
|До 3.6 словари `dict` и множества `set` не сохраняли порядок, но начиная с 3.7 *офицально упорядочены*

|_Дубликаты_
|Может содержать дубликаты
|Может содержать дубликаты
|Не содержит дубликатов

|_Индексация_
|+
|+
|-

|_Размер_
|Фиксированны
|Динамический
|Динамический

|_Подходит для_
|Последовательность не планируется изменять;
Если нужно поочередно перебирать неизменную последовательность элементов;
Нужна последовательность элементов для ее назначения в качестве ключа словаря. Поскольку списки -- это изменяемый тип данных, их нельзя применять в качестве ключей словаря;
Важна скорость выполнения операций с последовательностью: из-за отсутствия возможности изменения, кортежи работают куда быстрее списков;
|Последовательность планируется изменять;
Планируется добавлять новые элементы или удалять старые
|Базовая структура типа данных “множество” -- это хеш-таблица (Hash Table). Поэтому множества очень быстро справляются с проверкой элементов на вхождение, например содержится ли объект `x` в последовательности `a_set`. Идея заключается в том, что поиск элемента в хэш-таблице -- это операция `O(1)`, то есть операция с постоянным временем выполнения.

|===

TIP: По сути, если не нужно хранить дубликаты, то множество будет лучшим выбором, чем список.

=== Выводы
_“Преждевременная оптимизация -- корень всех зол”._

Итак, самое главное, что вам стоит запомнить по поводу списков, кортежей и множеств:

** Если необходимо хранить дубликаты, то выбирайте список или кортеж.

** Если НЕ планируется изменять последовательность после ее создания, то выбирайте кортеж, а не список.

** Если НЕ нужно хранить дубликаты, то воспользуйтесь множеством, так как они значительно быстрее определяют наличие объекта в последовательности.

CAUTION: В конечном итоге, по большей части не стоит слишком сильно задумываться о том, какого же типа данных последовательностью воспользоваться.
