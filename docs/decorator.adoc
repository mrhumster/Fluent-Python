include::./.asciidoctor/.asciidoctorconfig[]
== Глава 7. _Декораторы и функции замыкания_

TIP: Декоратор - это вызываемый объект, принимающий в качестве аргумента другую функцию.

=== Главное, что нужно знать о декораторах:

* Тот факт, что они властны заменить декорируемую функцию другой;

* Выполняется сразу после загрузки модуля;

=== Паттерн Стратегия, дополненный декоратором

.Список `promos` заполняется декоратором `promotion`
[source, python]
----
include::{sourcedir}/startegy_6.py[]
----

По сравнению с другими решениями, у этого есть несколько преимуществ:

* Функции, реализующие стратегии вычисления скидки могут избавиться от суффикса `_promo`

* Декоратор `@promotion` явно описывает назначение декорируемой функции и без труда позволяет временно отменить предоставление ссылки: достаточно закомментировать декоратор

* Стратегии скидки можно определить в других модулях.


=== Правила видимости переменных

Видимость локальных переменных определяется при компилировании байт-кода и если одноименная переменная определена в теле функции, то она будет считаться локальной.

=== Замыкания

Замыкание вступает в игру только при наличии вложенной функции.

TIP: Замыкание -- это функция с расширенной областью видимости, которая охватывает все не глобальные переменные, имеющие ссылки в теле функции, хотя они в нем не определены.

Эту идею довольно трудно переварить, поэтому пример.

Рассмотрим функцию `avg`, которая вычисляет среднее продолжающегося ряда чисел, например, среднюю цену закрытия биржевого товара за всю историю торгов. Каждый день ряд пополняется новой ценой, а при вычислении среднего учитываются все прежние цены.

.Если начать с чистого листа, то функция `avg` можно было бы использовать следующим образом:
[source, doctest]
----
include::{doctestdir}/avg.txt[]
----

.Вопрос на подумать
NOTE: Откуда берется `avg` и где она хранит предыдущие значения?

==== Реализация Average основанная на классах.

.average_oo.py: класс для вычисления накопительного среднего значения
[source, python]
----
include::{sourcedir}/average_oo.py[]
----

.Класс `Averager` создает вызываемые объекты
[source, doctest]
----
include::{doctestdir}/avg_oo.txt[]
----

.Результат тестирования
[source, doctest]
----
>>> import doctest
>>> doctest.testfile('./source/doctest/avg_oo.txt')
TestResults(failed=0, attempted=5)
----

==== Функциональная реализация с использованием функции высшего порядка `make_averager`

[source, python]
----
include::{sourcedir}/average.py[]
----

TIP: Обратите внимание на сходство обоих примеров: мы обращаемся к `Averager` и к `make_averager` что бы получить вызываемый объект `avg`, который обновляет временной ряд и вычисляет среднее значение.

Совершенно ясно, где хранит историю объектов `avg` класса `Averager`: в аттрибуте экземпляра `self.series`. Но где находится `series` функции `avg` из второго примера?

NOTE: Внутри `averager` переменная `series` является _свободной_. Этот технический термин обозначает, что переменная не связана в локальной области видимости.

TIP: *Python* хранит имена локальных и свободных переменных в аттрибуте `\\__code__`, который представляет собой откомпилированное тело функции.

.Инспекция функции, созданной функцией `make_averager`
[source, doctest]
----
include::{doctestdir}/avg_inspect.txt[lines=1..6]
----

Привязка переменной `series` хранится в аттрибуте `\\__closure__` возвращенной функцией `avg`.

TIP: Каждому элементу `avg.\\__closure__` соответствует имя в `avg.\\__code__.co_freevars`. Эти элементы называются _ячейками(cells)_, и у каждого из них есть атрибут `cell_contents`, где можно найти само значение.

.Инспекция функции, созданной функцией `make_averager` (продолжение)
[source, doctest]
----
include::{doctestdir}/avg_inspect.txt[lines=7..]
----

.Резюмируем:
NOTE: *Замыкание* -- это функция, которая запоминает привязку свободных переменных, существовавшие на момент определения функции. Так что их можно использовать впоследствии при вызове функции, когда область видимости, в которой она была определена уже не существует.

TIP: Единственная ситуация, когда функции может понадобиться доступ к внешней не глобальной переменной,- это когда она вложена в другую функцию.

==== Объявление `nonlocal`

Приведенная ранее реализация `make_averager` не эффективна. Мы храним в переменной все значения и каждый раз вычисляем их сумму при каждом вызове `averager`. Лучше было бы хранить предыдущую сумму и количество элементов, тогда зная два числа мы можем вычислить среднее.

.В Pyton 3 было добавлено nonlocal
NOTE: *nonlocal* позволяет пометить переменную как свободную, даже если ей присваивается значение внутри функции. В таком случае изменяется привязка, хранящаяся в замыкании.

.Правильная реализация идеи
[source, python]
----
include::{sourcedir}/averager_nonlocal.py[]
----

=== Реализация простого декоратора

.Простой декоратор для вывода времени выполнения функции
[source, python]
----
include::{sourcedir}/clock_decorator.py[]
----

.Использование декоратора clock
[source, python]
----
include::{sourcedir}/clock_decorator_demo.py[]
----

.Результат выполнения
[source, bash]
----
include::{doctestdir}/clock_decorator_demo_run.txt[]
----

=== Декораторы в стандартной библиотеке

Два самых любопытных декоратора в стандартной библиотеке - `lru_cache` и совсем новый `singledispatch` _(Python >= 3.4)_, оба определены в `functools`.

==== Кэширование с помощью `functools.lru_cache`

.Декоратор `functools.lru_cache` очень полезен на практике
NOTE: Он реализует "запоминание" (memorization): прием оптимизации, смысл которого заключается в запоминании дорогостоящих вычислений, позволяет избежать повторных вычислений с теми же аргументами, что и раньше.

.Пример использования кэширования
[source, python]
----
include::{sourcedir}/fibo_demo.py[]
----

На примере функция уже декорирована. Для сравнения, вот выводы декорированной и не декорированной функции `fibonacci`:

.Вывод скрипта без использования `lru_cache`. Очевидны лишние вычисления.
[source, bash]
----
include::{doctestdir}/fibo_demo_out.txt[lines=13..]
----

.Вывод скрипта c `lru_cache`.
[source, bash]
----
include::{doctestdir}/fibo_demo_out.txt[lines=1..12]
----

TIP: `lru_cache` необходимо вызывать как функцию со скобками. `functools.lru_cache()`. Причина в том, что декоратор принимает конфигурационные параметры.

.Полная сигнатура
NOTE: `functools.lru_cache(max_size=128, typed=False)`

* `maxsize` -- сколько результатов хранить (_для достижения результата maxsize = n^2^_).

* `type` - если стоит True, то результаты разных типов будут храниться порознь.

=== Одиночная диспетчеризация и обобщенные функции

`functools.singledispatch` - (Python >= 3.4) позволяет каждому модулю вносить свой вклад в общее решение, так, что пользователь может легко добавить специализированную функцию, даже не имея возможности изменить класс.

Обычная функция, декорированная `singledispatch` становится _обобщенной функцией_: группой функций, выполняющих одну и ту же логическую операцию по-разному в зависимости от типа первого аргумента.

.Декоратор `functools.singledispatch` создает функцию `htmlize.register` для объединения нескольких функций в одну обобщенную.
[source,python]
----
include::{sourcedir}/htmlize.py[]
----

Замечательное свойство данного декоратора в том, что специализированные функции можно зарегистрировать в любом месте системы, в любом модуле. Если в последствии, вы добавите модуль, содержащий новый пользовательский тип, то без труда сможете новую специализированную функцию для обработки данного типа.

.Возможности этого декоратора шире, подробнее можно почитать тут:
* https://www.python.org/dev/peps/pep-0443/[PEP-0443 Single-dispatch generic function]

=== Композиция декораторов

Когда два декоратора `@d1` и `@d2` применяются к одной и той же функции `f` в указанном порядке, получается то же самое, что и в результате композиции `f=d1(d2(f))`

=== Параметризованные декораторы

Для реализации параметризованного декоратора, необходимо создать _фабрику декораторов_. Т.е. создать функцию, которая возвращает декоратор.


=== Ссылочки

* https://wrapt.readthedocs.io/en/latest/[A Python module for decorators, wrappers and monkey patching.]

* https://pypi.org/project/decorator/[pip install decorator]

* https://wiki.python.org/moin/PythonDecoratorLibrary[Python Decorator Library]

* https://www.python.org/dev/peps/pep-0443/[PEP 443 -- Single-dispatch generic functions]

* https://www.python.org/dev/peps/pep-3104/[PEP 3104 -- Access to Names in Outer Scopes]

