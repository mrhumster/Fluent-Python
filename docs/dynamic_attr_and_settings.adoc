:icons: font

== Глава 19. Мета программирование

=== Динамические атрибуты и свойства

"Ценность свойств заключается в том, что благодаря им можно совершенно безопасно -- и это даже рекомендуется -- раскрывать атрибуты-данные как часть открытого интерфейса классаfootnote:[Alex Martelli «Python in a Nutshell», издание 2 (O'Reilly), стр 101.]."
-- Алекс Мартелли, один из разработчиков Python и автор книги.

Атрибуты-данные и методы в Python носят общее название «атрибуты»; *метод* -- это просто _вызываемый_ атрибут. Помимо атрибутов-данных и методов, мы можем создавать ещё свойства, позволяющие заменить открытые атрибуты-данные методами-акцепторами (т.е. методами чтения и установки), не изменяя интерфейс класса. Это согласуется с _принципом единообразного доступа_.

NOTE: Все сервисы, предоставляемые модулем, должны быть доступны с помощью единообразной нотации, скрываюшей механизм реализации: хранение или вычислениеfootnote:[Bertrand Mayer, Object-Oriented Software Construction, издание 2, стр. 57.].

Помимо свойств, Python предлагает богатый API для управления доступом к атрибутам и реализации динамических атрибутов. Интерпретатор вызывает специальные методы `\\__getattr__` и `\\__setattr__` при использовании нотации доступа к атрибутам с помощью точки (например, `obj.attr`). Пользовательский класс, в котором имеется метод `\\__getattr__`, может реализовать "виртуальные атрибуты", вычисляемые "на лету", когда программа пытается прочитать несуществующий атрибут.

Динамические атрибуты -- вид метапрограммирования, обычно применяемый создателями каркасов.

.`osconfeed.py`: загрузка файла osconfeed.json
[source, python]
----
include::../source/osconfeed.py[]
----

=== Исследование JSON-подобных данных с динамическими атрибутами

.Класс `FrozenJSON` позволяет читать атрибуты, например `name`, и вызывать методы, например `.keys()` и `.items()`
[source, python]
----
include::../source/explore0.py[]
----

==== Проблема не допустимого элемента

Суть простая, если атрибут - это зарезервированное слово из Python, то при попытке запросить данный атрибут мы получим синтаксическую ошибку. Что бы поправить этот косяк необходимо для таких атрибутов добавлять в конце символ "_".

Для этого достаточно изменить однострочный класс `\\__init__`:

[source, python]
----
include::../source/explore1.py[]
----


==== Гибкое создание объектов с помощью метода `\\__new__`

Мы часто называем `\\__init__` конструктором, но это только потому, что позаимствовали терминологию из других языков. На самом деле конструирует экземпляр специальный метод `\\__new__`. Этот метод класса (однако он обрабатывается особым образом, поэтому декоратор `@classmethod` не используется), и возвращать он должен экземпляр. Этот экземпляр затем передаётся в качестве первого аргумента `self` методу `\\__init__`. Поскольку `\\__init__` при вызове уже получает экземпляр, что-то возвращать ему запрещено, по существу, метод `\\__init__` является "инициатором". _Настоящий конструктор_ - это метод `\\__new__`, но мы о нём редко вспоминаем, потому что реализации, унаследованной от класса `object`, обычно достаточно.

NOTE: Описанный только что путь -- от `\\__new__` к `\\__init__` -- самый распространённый, но не единственный. Метод `\\__new__` может возвращать и экземпляр другого класса; если такое происходит, то интерпретатор не вызывает `\\__init__`.

.Псевдокод конструирования объекта
[source, python]
----
def object_maker(the_class, some_arg):
    new_object = the_class.__new__(some_arg)
    if isinstance(new_object, the_class):
        the_class.__init__(new_object, some_arg)
    return new_object

# следующие предложения приблизительно эквивалентны
x = Foo('bar')
x = object_maker(Foo, 'bar')
----

.`explore2.py`: использование `__new__` вместо `build` для конструирования новых объектов, которые могут быть или не быть экземплярами FrozenJSON.
[source, python]
----
include::../source/explore2.py[]
----

=== Использование свойств для контроля атрибутов

==== LineItem, попытка №1: класс строки заказа

Представим себе приложение для магазина, который продаёт натуральные пищевые продукты на развес. В такой системе заказ состоит из последовательности строк, а каждую строку можно представить классом, показанным в примере:

.`bulkfood_v1.py`: простейший класс `LineItem`
[source, python]
----
include::../source/bulkfood_v1.py[]
----

Красиво и просто. Пожалуй, слишком просто. Ниже обозначим проблемку:

[source, doctest]
----
>>> from source.bulkfood_v1 import LineItem
>>> raisins = LineItem('Golden raisins', 10, 6.95)
>>> raisins.subtotal()
69.5
>>> raisins.wight = -20 # Мусор на входе
>>> raisins.subtotal()  # Мусор на выходе
-139.0
----

Как это исправить? Можно было бы изменить интерфейс класса `LineItem`, добавив методы чтения и установки атрибута `weight`. Так поступают в Java, и ничего плохого в этом нет.

С другой стороны, было бы естественно устанавливать атрибут `weight` элементы заказа, просто присваивая ему значение, да и не исключено, что в других частях эксплуатируемой системы уже встречается прямой доступ к атрибуту вида `item.weight`. В таком случае следовало бы заменить атрибут-данные свойством -- это было бы в духе Python.

==== LineItem, попытка №2: контролирующее свойство

.`bulkfood_v2.py`: класс `LineItem` со свойством `weight`
[source, python]
----
include::../source/bulkfood_v2.py[]
----

.Теперь объект `LineItem` с недопустимым весом создать не возможно
[source, doctest]
----
>>> from source.bulkfood_v2 import LineItem
>>> apples = LineItem('Ligol apple', 1.5, 140)
>>> apples.subtotal()
210.0
>>> apples.weight = -2
Traceback (most recent call last):
...
    raise ValueError('value must be > 0')
ValueError: value must be > 0
----

TIP: Было бы неплохо защитить от подобных ошибок и поле с ценой и преобразовать в `price` в свойство, но это бы повлекло за собой частичное повторение кода. Лекарство от повторения -- абстрагирование.

Существует 2 способа абстрагировать определения свойств: фабрика свойств и дескрипторный класс. Продолжим наше исследование и реализуем фабрику свойств в виде функции.

=== Правильный взгляд на свойства

Встроенная сущность `property` часто используется как декоратор, но в действительности она является классом.

.Сигнатура конструктора класса `property`:
****
`property(fget=None, fset=None, fdel=None, doc=None)`

Все аргументы необязательны; если для какого-то из них не указана функция, то результирующий объект свойства не поддерживает соответствующую операцию.

NOTE: Тип `property` появился в версии Python 2.2, но синтаксис декоратора был добавлен только в версии Python 2.4, т.е. на протяжении нескольких лет свойства нужно было определять, передавая функции-акцессоры в первых двух аргументах.

.`bulkfood_v2b.py`: то же, что и в примере выше, но без декоратора
[source, python]
----
include::../source/bulkfood_v2b.py[]
----
****

В некоторых случаях классическая форма удобнее синтаксиса декораторов, одним из примеров является код фабрики свойств, который мы вскоре обсудим. С другой стороны, в теле класса, где много методов, декораторы позволяют сразу опознать методы чтения и установки, не полагаясь на соглашение о префиксах `get` и `set` в именах.

=== Свойства переопределяют атрибуты экземпляра

WARNING: Если экземпляр и его класс оба имеют атрибут-данные с одним и тем же именем, то атрибут экземпляра переопределяет или маскирует атрибут класса - по крайней мере, когда мы обращаемся к атрибуту от имени этого экземпляра.

.Атрибут экземпляра маскирует атрибут-данные класса
[source, python]
----
class Class:
    """
    Определяем Class с двумя атрибутами класса:
    атрибутом-данными data и свойством prop.
    """
    data = 'the class data attr'
    @property
    def prop(self):
        return 'the prop value'
----

[source, doctest]
----
>>> obj = Class()
>>> vars(obj)         # vars возвращает атрибут __dict__ объекта obj;
{}                    # как видим, атрибутов экземпляра в нём нет.

>>> obj.data          # Чтение из obj.data возвращает значение Class.data.
'the class data attr'

>>> obj.data = 'bar'  # Запись в obj.data создаёт атрибут экземпляра.
>>> vars(obj)         # Инспектируем, чтобы узнать, какие у него атрибуты.
{'data': 'bar'}

>>> obj.data          # Теперь, читая obj.data, мы получим значение атрибута/
'bar'

>>> Class.data        # Атрибут Сlass.data не изменился.
'the class data attr'

>>> Class.prop        # Чтение prop из Class возвращает сам объект свойств,
...                   # при этом его метод чтения не выполняется.
<property object at 0x0000018E39C619E0>

>>> obj.prop          # Чтение obj.prop приводит к выполнению метода чтения.
'the prop value'

>>> obj.prop = 'foo'  # Попытка установить атрибут экземпляра prop завершается ошибкой.
Traceback (most recent call last):
...
  File "<input>", line 1, in <module>
AttributeError: can't set attribute 'prop'

>>> obj.__dict__['prop'] = 'foo'    # Запись 'prop' напрямую в obj.__dict__ работает.
>>> vars(obj)         # Теперь у obj есть два атрибута экземпляра: data и prop.
{'prop': 'foo', 'data': 'bar'}

>>> obj.prop          # Однако при чтении obj.prop по-прежнему выполняется метод
'the prop value'      # чтения свойства. Свойство не маскируется атрибутом экземпляра.

>>> Class.prop = 'baz'# В случае перезаписывания Class.prop объект свойств уничтожается.
>>> obj.prop          # Теперь чтение obj.prop возвращает атрибут экземпляра.
'foo'                 # Class.prop больше не является свойством.

>>> obj.data          # obj.data возвращает атрибут экземпляра data.
'bar'
>>> Class.data        # Class.data возвращает атрибут класса data.
'the class data attr'
                      # Перезаписываем Class.data новым свойством
>>> Class.data = property(lambda self: 'the "data" prop value')
>>> obj.data          # Теперь Class.data маскирует obj.data.
'the "data" prop value'
>>> del Class.data    # Удаляем свойство.
>>> obj.data          # Теперь obj.data снова возвращает атрибут экземпляра data.
'bar'
----

NOTE: В этом разделе мы, хотели показать, что при вычислении выражения вида `obj.attr` поиск `attr` начинается не с `obj`. На самом деле, поиск начинается с `obj.\\__class__` и, только если в классе не существует свойства с именем `attr`, то Python заглядывает в сам объект `obj`. Это правило применимо не только к свойствам, но и к целой категории дескрипторов: _переопределяющим дескрипторам_.

==== Документирование свойств

Когда функция оболочки `help()` или интегрированной среде разработки нужно вывести документацию по свойству, она получает информацию из атрибута свойства `\\__doc__`.

.Конструктор класса `property` может получить строку документации в виде аргумента `doc`:
****
`weight = property(get_weight, set_weight, doc='Вес в килограммах')`
****

Если свойство объявлено с помощью декоратора, то строка документации метода чтения - того, который снабжён декоратором `@property`, -- становится документацией свойства в целом.

[source, python]
----
class Foo:
    @property
    def bar(self):
        """The bar attribute"""
        return self.__dict__['bar']


    @bar.setter
    def bar(self, value):
        self.__dict__['bar'] = value
----

.Строка документации для класса из примера
[source, doctest]
----
>>> help(Foo.bar)
Help on property:
    The bar attribute

>>> help(Foo)
Help on class Foo in module __main__:
class Foo(builtins.object)
 |  Data descriptors defined here:
 |
 |  __dict__
 |      dictionary for instance variables (if defined)
 |
 |  __weakref__
 |      list of weak references to the object (if defined)
 |
 |  bar
 |      The bar attribute
 |
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |
 |  __annotations__ = {}

----

=== Программирование фабрики свойств

Мы создадим фабрику свойств `quantity`.

NOTE: Свойства - атрибуты класса. При создании каждого свойства с помощью `quantity` мы должны передать им имя атрибута `LineItem`, который будет управляться этим свойством.

.`bulkfood_v2prop.py`: фабрика свойств `quantity` в действии
[source, python]
----
include::../source/bulkfood_v2prop.py[]
----

.`bulkfood_v2prop.py`: фабрика свойств `quantity`
[source, doctest]
----
>>> nutmeg = LineItem('Moluccan nutmeg', 8, 13.95)
>>> nutmeg.weight, nutmeg.price   # Чтение weight и price с помощью свойств
...                               # маскирует одноимённые атрибуты экземпляра.
(8, 13.95)
>>> sorted(vars(nutmeg).items())  # Используйте метод vars, чтобы проинспектировать
...                               # экземпляр nutmeg: видно, в каких точно атрибутах
...                               # экземпляра хранится значения.
[('description', 'Moluccan nutmeg'), ('price', 13.95), ('weight', 8)]
----

=== Удаление атрибутов

.Напомним, что в учебном пособии по Python описано предложение `del` для удаления атрибутов объекта.
TIP: `del my_object.an_attribute`

В определении свойства декоратор `@my_property.deleter` используется, что бы обернуть метод, отвечающий за удаление атрибута, управляемого свойством.

.`blackknight.py`: идея подсказана персонажем Black Knight из скетча "Monty Python and the Holy Grain".
[source, python]
----
include::../source/blackknight.py[]
----

NOTE: Если используетесь не декоратор, а классический синтаксис, то для задания метода удаления применяется именованный аргумент `fdel`.

`member = property(member_getter, *fdel*=member_deleter)`

Если вы не пользуетесь свойствами, то для удаления атрибута можно было бы также реализовать низкоуровневый метод `\\__delattr__`, описанный в разделе _"Специальные методы для управления атрибутами"_ ниже.

=== Важные атрибуты и функции для работы с атрибутами

==== Специальные атрибуты, влияющие на обработку атрибутов

.`\\__class__`
Ссылка на класс объекта (т.е. `obj.\\__class__` -- то же самое, что `type(obj)`). Python ищет специальные методы, например `\\__getattr__`, только в классе объекта, а не в самих экземплярах.

.`\\__dict__`
Отображение, в котором хранится изменяемые атрибуты объекта или класса. Если у объекта есть этот атрибут, то его можно в любой момент наделить новыми атрибутами. Если в классе есть атрибут `\\__slots__`, то у его экземпляра не может быть атрибута `\\__dict__`.

.`\\__slots__`
Этот атрибут можно определить в классе, чтобы ограничить состав атрибутов у экземпляров этого класса. `\\__slots__` представляет собой кортеж строк с именами допустимых атрибутовfootnote:[Алекс Мартелли отмечает, что `\\__slots__` может быть и списком, но лучше не оставлять места для недоразумений и всегда использовать кортеж, потому что изменение списка, хранящегося в `\\__slots__`, после обработки тела класса интерпретатором, не возымеет никакого эффекта, так что использование здесь изменяемой последовательности лишь стало бы причиной вредных иллюзий.].

==== Встроенные функции для работы с атрибутами

.`dir([_object_])`
Перечисляет большую часть атрибутов объекта. В https://docs.python.org/3/library/functions.html#dir[официальной документации] сказано, что дананя функция предоставляет не все атрибуты, а наиболее интересныеfootnote:[*Примечание* Поскольку `dir()` предоставляется в первую очередь для удобства использования в интерактивной подсказке, он пытается предоставить интересный набор имен больше, чем пытается предоставить строго или последовательно определенный набор имен, и его детальное поведение может меняться в разных выпусках. Например, атрибуты метакласса отсутствуют в списке результатов, если аргументом является класс.].

.`getattr(_object_, name[, default])`
Получает атрибут, идентифицируемый строкой `name`, объекта `_object_`. В результате может быть найден атрибут, определённый в классе или супер-классе объекта. Если такого атрибуты не существует, возбуждается исключение `AttributeError`, либо возвращает значении `default`, если оно задано.

.`hasattr(_object_, name)`
Возвращает `True`, если атрибут с указанным именем существует в объекте `_object_` или может быть найден с его помощью (например, в результате наследования).

.`setattr(_object_, name, value)`
Присваивает значение `value` поименованному атрибуту `_object_`, если это допускается. В результате может быть создан новый атрибут или переименован старый.

.`vars([_object_])`
Возвращает атрибут `\\__dict__` объекта `_object_`; функция `vars` не умеет работать с классами, в которых определён атрибут `\\__slots__` и нет атрибута `\\__dict__` (в отличии от фунции `dir`, которая справляется с такими экземплярами). Без аргумента `vars()` делает то же самое, что `locals(): возвращает словарь, описывающий  локальную область видимости.

==== Специальные методы для работы с атрибутами

Специальные методы, описанные ниже, отвечают за чтение, установку, удаление и получение списка атрибутов(если они реализованы в пользовательском классе).

.`\\__delattr__(self, name)`
Вызывается при любой попытке удалить атрибут в предложении `del`, например, `del obj.attr` приводит к вызову `Class.\\__delattr__(obj, 'attr')`.

.`\\__dir__(self)`
Вызывается при вызове `dir` для объекта с целью получить список атрибутов.

.`\\__getattr__(self, name)`
Вызывается только тогда, когда попытка найти поименованный атрибут в obj.Class и супер-классах завершается неудачно.

.`\\__getattribute__(self, name)`
Вызывается при любой попытке получить поименованный атрибут за исключением случаев, когда  искомый атрибут является специальным атрибутом или методом. К вызову этого метода приводит использование нотации с точкой и встроенной функции `getattr` и `hasattr`.

.`\\__setattr__(self, name, value)`
Вызвается при любой попытке установить поименованный атрибут. К вызову этого метода приводит использование нотации с точкой и встроенной функции `setattr`.


