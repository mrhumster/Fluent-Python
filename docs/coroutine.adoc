include::./.asciidoctor/.asciidoctorconfig[]

== Глава 16. Сопрограммы

NOTE: Строка вида `yield item` порождает(производит) значение, которое получает сторона, вызывающая `next(...)`, и кроме того, она уступает процессор, приостанавливая выполнение генератора, что бы _вызывающая_ сторона могла продолжить работу до момента, когда ей понадобится следующее значение от `next()`. _Вызывающая_ сторона "вытягивает" значения из генератора.

*Сопрограмма* синтаксически выглядит как генератор: просто функция в теле которой встречается ключевое слово `yield`. Однако в сопрограмме `yield` обычно находится в правой части выражения присваивания (пр.: `datum = yield`) и может порождать или не порождать значения -- если после слова `yield` нет никакого выражения, генератор отдает `None`. *Сопрограмма* может получать данные от _вызывающей_ стороны, если та вместо `next(...)` воспользуется методом `.send(datum)`. Обычно _вызывающая_ сторона отправляет сопрограмме значения.

NOTE: Сопрограмма может находиться в одном из четырех состояний. Узнать, в каком именно, позволяет функция `inspect.getgeneratorstate(...)`.

`GEN_CREATED` -- _Ожидает начала выполнения_.

`GEN_RUNNING` -- _Выполняется интерпретатором_.

`GEN_SUSPENDED` -- _Приостановлена в выражении_ `yield`.

`GEN_CLOSED` -- _Исполнение завершилось_.


=== Пример: сопрограмма для вычисления накопительного среднего

.`coroaverager0.py`: сопрограмма для вычисления накопительного среднего
[source, python]
----
include::{sourcedir}/coroaverager0.py[]
----

=== Декоратор для инициализации сопрограммы

Пока сопрограмма не инициализирована, она почти бесполезна, нужно не забыть вызвать `next(my_coro)` до `my_coro.send(x)`. Что бы облегчить работу иногда используют инициализирующий декоратор.

.`coroutil.py`: декоратор для инициализации сопрограммы.
[source, python]
----
include::{sourcedir}/coroutil.py[]
----

.`coroaverager1.py`: код сопрограммы с использованием инициализирующего декоратора
[source, python]
----
include::{sourcedir}/coroaverager1.py[]
----

=== Завершение сопрограммы и обработка исключений

Необработанное исключение распространяется в функцию, из которой был произведён вызов `next` или `send`, приведший к исключению.

.Как не обработанное исключение аварийно завершает сопрограмму
[source, doctest]
----
>>> from source.coroaverager1 import averager
>>> coro_avg = averager()
>>> coro_avg.send(40)
40.0
>>> coro_avg.send(50)
45.0
>>> coro_avg.send('spam')
Traceback (most recent call last):
...
TypeError: unsupported operand type(s) for +=: 'float' and 'str'
>>> coro_avg.send(60)
Traceback (most recent call last):
  File "C:\Users\User\AppData\Local\Programs\Python\Python310\lib\code.py", line 90, in runcode
    exec(code, self.locals)
  File "<input>", line 1, in <module>
StopIteration
----

Отправка не числового значения приводит к исключению в сопрограмме. Поскольку исключение не обрабатывается сопрограммой, она завершается. Любая попытка вновь активировать сопрограмму вызовет исключение `StopIteration`.

Приведенный пример показывает возможный способ завершения сопрограммы: послать некоторое специально значение, которое сопрограмма интерпретирует как признак завершения. Удобным кандидатом на эту роль является константные встроенные значения _синглтоны_, например `None` и `Ellipsis`. У `Ellipsis` к тому же есть то достоинство, что в обычных потоках данных он практически не встречается. Так же встречается в качестве признака сам класс `StopIteration`, а не его экземпляр (и без возбуждения исключения такого типа), т.е. таким образом: `my_coro.send(StopIteration)`.

Начиная с версии Python 2.5, у объектов-генераторов есть два метода которые позволяют клиенту явно отправить сопрограмме исключение: `throw` и `close`.

`generator.throw(exc_type[, exc_value[, traceback]])` -- приводит к тому, что выражение `yield`, в котором генератор приостановлен, возбуждается исключение. Если генератор обрабатывает исключение, то выполнение продолжится до следующего `yield`, а отданное значение станет значением вызова `generator.throw`. Если же исключение не обработано генератором, то оно распространяется в контекст вызывающей стороны.

`generator.close()` -- выражение `yield`, в котором генератор приостановлен, возбуждает исключение `GeneratorExit`. Если генератор не обработает данное исключение или возбудит исключение `StopIteration` -- обычно в результате выполнения до конца -- вызывающая сторона не получит никакой ошибки. Получив исключение `GeneratorExit`, генератор *не должен* отдавать значения, иначе возникнет исключение `RuntimeError`. Если генератор возбудит другое исключение, то оно распространится в контексте вызывающей стороны.


NOTE: Официальная документация по методам объекта-генератора https://docs.python.org/3/reference/expressions.html#generator-iterator-methods

.`coro_exc_demo.py`: тестовый код для изучения обработки исключений в сопрограммах
[source, python]
----
include::{sourcedir}/coro_exc_demo.py[]
----

Последняя строка в примере не достижима, потому что из бесконечного цикла можно выйти только в результате необработанного исключения, а это приводит к немедленному завершению сопрограммы.

.Активация и завершени `demo_exc_handling` без исключения
[source, doctest]
----
>>> exc_coro = demo_exc_handling()
>>> next(exc_coro)
--> coroutine started
>>> exc_coro.send(11)
--> coroutine received: 11
>>> exc_coro.send(22)
--> coroutine received: 22
>>> exc_coro.close()
>>> from inspect import getgeneratorstate
>>> getgeneratorstate(exc_coro)
'GEN_CLOSED'
----

Если в `demo_exc_handling` методом `throw` передано исключение `DemoException`, то оно обрабатывается, и сопрограмма продолжится, как показано в примере ниже.

.Возбуждение исключения `DemoException` не приводит к выходу из нее
[source, doctest]
----
>>> from source.coro_exc_demo import demo_exc_handling, DemoException
>>> exc_coro = demo_exc_handling()
>>> next(exc_coro)
--> coroutine started
>>> exc_coro.send(11)
--> coroutine received: 11
>>> exc_coro.throw(DemoException)
*** DemoException handled. Continuing...
>>> from inspect import getgeneratorstate
>>> getgeneratorstate(exc_coro)
'GEN_SUSPENDED'
----

С другой стороны, если возбуждённое в сопрограмме исключение не обработано, то она останавливается и переходит в состояние `GEN_CLOSED`.

.Сопрограмма завершается, если не может обработать возбуждённое в ней исключение
[source, doctest]
----
>>> exc_coro = demo_exc_handling()
>>> next(exc_coro)
--> coroutine started
>>> exc_coro.throw(ZeroDivisionError)
Traceback (most recent call last):
...
    x = yield
ZeroDivisionError
>>> getgeneratorstate(exc_coro)
'GEN_CLOSED'
----

Если необходимо, чтобы вне зависимости от способа завершения сопрограммы был выполнен какой-то код очистки, то соответсвующую часть тела сопрограммы нужно обернуть блоком `try\finally`, как показано в примере ниже.

.`coro_finally_demo.py`: использование `try\finally` для выполнения некоторых действий по завершении сопрограммы
[source, python]
----
include::{sourcedir}/coro_finally_demo.py[]
----

NOTE: Одна из основных причин добавления конструкции `yield from` в *Py >= 3.3* имеет отношение к возбуждению исключений во вложенных сопрограммах. Другая причина -- обеспечить более удобный возврат значений их сопрограмм.

=== Возврат значений из сопрограммы

Некоторые сопрограммы не отдают ничего интересного, а написаны с целью вернуть значение в конце -- зачастую некий аккумулированный результат.

.`coroaverager2.py`: сопрограмма `averager`, возвращающая результат
[source, python]
----
include::{sourcedir}/coroaverager2.py[]
----

[source, doctest]
----
>>> from source.coroaverager2 import averager
>>> coro_avg = averager()
>>> next(coro_avg)
>>> coro_avg.send(10)   # Эта версия не отдает значений
>>> coro_avg.send(20)
>>> coro_avg.send(30)
>>> coro_avg.send(6.5)
>>> coro_avg.send(None) # Отправка None приводит к выводу из цикла и завершению сопрограммы  возвратом результата.
Traceback (most recent call last):
...
StopIteration: Result(count=4, average=16.625)
----

TIP: Как обычно, генератор возбуждает исключение `StopIteration`. Возвращаемое значение можно прочитать из атрибута исключения `value`.

.Перехват `StopIteration` позволяет получить значение, возвращаемое `averager`
[source, doctest]
----
>>> from source.coroaverager2 import averager
>>> coro_avg = averager()
>>> next(coro_avg)
>>> coro_avg.send(10)
>>> coro_avg.send(30)
>>> coro_avg.send(6.5)
>>> try:
...     coro_avg.send(None)
... except StopIteration as exc:
...     result = exc.value
...
>>> result
Result(count=3, average=15.5)
----

=== Использование `yield from`

`yield from` -- совершенно новая конструкция. Она уместна настолько больше `yield`, что использование одного и того же слова только вводит в заблуждение. Аналогичные конструкции в других языках называют `await`.

NOTE: Основное применение `yield from` -- открытие двустороннего канала между внешней вызывающей программой и внутренним субгенератором, так что бы значения можно было отправлять и отдавать напрямую, а исключения возбуждать и обрабатывать без написания громоздкого стереотипного кода и промежуточных сопрограмм. Это открывает новую возможность -- делегирование сопрограмме.

.`coroaverager3.py`: использование `yield from` для управления сопрограммой `averager` и печати соответствующего отчёта.
[source, python]
----
include::{sourcedir}/coroaverager3.py[]
----

.По поводу `send(None)`
TIP: Если субгенератор не остановить, при помощи `None`, то инициализирующий генератор будет навечно заблокирован в `yield from`.

Данный пример показывает простейшую конфигурацию `yield from`, когда имеется только один делегирующий генератор и один субгенератор. Поскольку делегирующий генератор работает как канал, мы можем соединить любое их количество, сформировав конвейер.

