include::./.asciidoctor/.asciidoctorconfig[]
== Глава 3. Словари и множества

Все словари наследуют класс *collections.abc.Mapping*. Ключи должны быть хэшируемые. Включать метод __hash__() и __eq__()
Объект называется хэшируемым, если он обладает хэш-значением, которое не изменяется на протяжении всей жизни объекта и
допускает сравнение с другими объектами.

.Способы инициализации словаря
[source,python]
----
a = dict(one=1, two=2, three=3)
b = {'one': 1, 'two': 2, 'three': 3}
c = dict(zip(['one','two','three'],[1,2,3]))
d = dict([('two', 2), ('one', 1), ('three', 3)])
e = dict({'two': 2, 'one': 1, 'three': 3})
a == b == c == d == e
True
----

== Глава 4. Тексты и байты.

Всё что нужно знать о байтах: главное это то, что существует 2 основных типа отображения двоичных
последовательностей: изменяемы тип bytes, появившийся в py3 и не изменяемы тип bytearray.
Каждый элемент bytes или bytearray - целое число от 0 до 255


== Глава 5. Полноправные функции

=== Семь видов вызываемых объектов

Оператор () можно применять не только к функциям, определённым пользователями. Что бы понять является ли объект вызываемым, воспользуейтесь функцией:

[source,python]
callable()

.Вызываемые элементы Python
[options="header", grid=rows, frame=none]
|===
|Функция|Описание
|_Пользовательские функции_|Создаются при помощи выражения `def` или `lambda`-выражения
|_Встроенные функции_|Функции написанные на C (в случае CPython), например `len` или `time.strftime`
|_Методы_|Функции определённые в теле класса
|_Встроенные методы_|Метода написанные на C, например dict.get
|_Классы_|При вызове класса выполняется свой метод `__new__`, что бы создать экземпляр, затем вызывает метод `__init__` для его инициализации и, наконец, возвращает экземпляр вызывающей программе
|_Экземпляры классов_|Если в классе определен метод `__call__`, то его экземпляры можно вызвать, как функции
|_Генераторные функции_|Функции или методы, в которых используется ключевое слово `yield`. При вызове генераторная функция возвращает объект-генератор
|===

NOTE: Учитывая разнообразие вызываемых типов в Python, самый безопасный способ узнать, является ли объект вызываемым, - воспользоваться встроенной функцией callable()

=== Пользовательские вызываемые типы

.Пример создания класса с реализованным методом `\\__call__`
[source,python]
----
include::{sourcedir}/bingocall.py[]
----

.Демонстрация BingoCage
[source, doctest]
----
include::{doctestdir}/bingocall.txt[]
----

TIP: Объект `bingo` можно вызвать как функцию, и встроенная функция `callable(...)` распознает его как вызываемый объект



.Пример классного разбора именованых и не именовых аргументов функции
[source,python]
----
include::{sourcedir}/tag.py[]
----


=== Получение информации о параметрах

* У объекта-функции есть аттрибут `__defaults__`, в котором хранится кортеж со значениями по умолчанию позиционных и именованных параметров.
* Значения чисто именованных аргументов находятся в `__kwdefaults__`
* Сами имена параметров находятся в атрибуте `__code__`, который содержится ссылку на объект `code` с множеством своих собственных параметров

[source, doctest]
----
include::{doctestdir}/tag.txt[]
----

=== inspect.signature
Метод `inspect.signature` возвращает объект inspect.Signature, у которого есть аттрибут `parameters`, позволяющий прочитать упорядоченное отображение имен на объекы типа `inspect.Parameter`. У каждого объекта `Parameter` есть набор аттрибутов, например: `name`, `default` и `kind`. Специально значение `inspect._empty` обозначающий параметры, не имеющие значения по-умолчанию.

[source,python]
----
include::{doctestdir}/signature.txt[]
----

У объекта `inspect.Signature` имеется метод `bind`, который принимает любое количество атрибутов и связывает их с параметрами, указанных в сигнатуре, следуя обычным правилам сопоставления фактических аргументов с формальными параметрами.

TIP: Каркас может использовать эту возможность для проверки аттрибутов до фактического вызова функции.

.Связывание сигнатуры функции `tag` со словарём аргументов
[source,doctest]
----
include::{doctestdir}/tag_2.txt[]
----

NOTE: На этом примере видно, как модель данных Python - посредством модуля inspect - раскрывает механизм, которым пользуется сам интерпретатор дя связывания аргументов с формальными параметрами при вызове функии.

=== Аннотация функций
.Аннотированная функция clip
[source, python]
----
include::{sourcedir}/clip_annot.py[]
----

* У любого аргумента в объявлении функции может быть выражение аннотации, которому предшествует `:`.
* Если у аргумента есть значение по-умолчанию, то аннотация располагается между именем и знаком `=`.
* Что-бы аннотировать возвращаемое значение, поместите `->` и вслед за ним выражение между знаком `)` и двоеточием в конце объявления функции.
* Аннотации никак не обрабатываются. Они просто сохраняются в аттрибуте функции `\\__annotations__` тип `dict`

[source, doctest]
----
>>> from source.clip_annot import clip
>>> clip.__annotations__
{'text': <class 'str'>, 'max_len': 'int > 0', 'return': <class 'str'>}
----

=== Пакеты для функционального программирования
==== Модуль `operator`

Модуль `operator` включает в себя функции для выборки элементов из последовательностей и чтения атрибутов объектов: `itemgetter` и `attrgetter` строят специализированные функции для выполнения этих действий.

.Результат применения `itemgetter` для сортировки списка кортежей
[source, python]
----
include::{sourcedir}/metro_data.py[]
----

[source, shell script]
----
py .\metro_data.py
('Sao Paulo', 'BR', 19.649, (-23, -46))
('Delhi NCR', 'IN', 21.935, (28, 77))
('Tokyo', 'JP', 36.933, (35, 139))
('Mexico City', 'MX', 20.142, (19, -99))
('New York-Newark', 'US', 20.104, (40, -74))
----


=== Фиксация аргументов с помощью `functools.partial`

В модуле `functools` собраны некоторые функции высшего порядка. Из них наиболее широко известна функция `reduce`. Помимо неё, особенно полезна функция `partial` и её вариация `partialmethod`.

* `functools.partial` -- функция высшего порядка. Позволяет применять функцию "частично". Получив на вход некоторую функцию, `partial` создает новый вызываемый объект, в котором некоторые аргументы исходной функции фиксированы. Функция `partial` принимает в первом аргументе вызываемый объект, а за ним - произвольное число позиционных и именованных аргументов, подлежащих связыванию.

.Построение вспомогательной функции нормализации Unicode-строк с помощью partial
[source, doctest]
----
>>> import functools
>>> import unicodedata
>>> nfc = functools.partial(unicodedata.normalize, 'NFC')
>>> s1 = 'café'
>>> s2 = 'cafe\u0301'
>>> nfc(s1) == nfc(s2)
True
>>> s1 == s2
False
----

* `functools.partialmethod` -- делает тоже самое, что и `partial`, но предназначена для работы с методами.

=== Спецификации и статьи по пройденному материалу:
. https://www.python.org/dev/peps/pep-3102/[PEP 3102 -- Keyword-Only Arguments]
. https://www.python.org/dev/peps/pep-3107/[PEP 3107 -- Function Annotations]
. https://www.python.org/dev/peps/pep-0362/[PEP 362 -- Function Signature Object]
. https://docs.python.org/3/howto/functional.html[Functional Programming HOWTO]


