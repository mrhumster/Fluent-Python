include::./.asciidoctor/.asciidoctorconfig[]

== Глава 10. Рубим, нарезаем и перемешиваем последовательности

=== Vector, попытка N1: совместимость с Vector2d

В этой главе мы напишем класс Vector для многомерного массива.

.Vector, попытка №1: совместимость с Vector2d
[source, python]
----
include::../source/vector_nd.py[]
----

NOTE: `reprlib.repr` - эта функция порождает безопасное представление длинной или рекурсивной структуры путём ограничения длины выходной строки с заменой отброшенного окончания многоточием `...`. При написании метода `\\__repr__` я мог бы вывести упрощённое отображение `components` с помощью такого выражения: `reprlib.repr(list(self._components)`. Но это было бы расточительно, поскольку пришлось бы копировать каждый элемент `self._components` в `list` только для того, что бы использовать `list repr`. Вместо этого можно применить `reprlib.repr` непосредственно к `self._components`, а затем отбросить все символы, оказавшиеся вне квадратный скобок `[]`.

TIP: Поскольку метод `repr` используется для отладки, он никогда не должен возбуждать исключение. Если в `\\__repr__` происходит какая-то ошибка, Вы должны обработать её сами и сделать всё возможное, что бы показать пользователю нечто разумное, позволяющее идентифицировать объект.

=== Протоколы и динамическая типизация

В ООП *_протоколом_* называется неформальный интерфейс, определённый только в документации, но не в коде. Например, протокол последовательности в Python подразумевает только наличие методов `\\__len__` и `\\__getitem__`. Любой класс `Spam`, в котором есть такие методы со стандартной сигнатурой и семантикой, можно использовать всюду, где ожидается последовательность. Является `Spam` подклассом какого-то другого класса или нет, роли не играет.

.Пример реализации последовательности
[source, python]
----
include::{sourcedir}/deck.py[]
----

Любому опытному программисту на Python достаточно одного взгляда, что бы понять что это именно класс последовательность. Несмотря на то, что он является подклассом `object`. Мы говорим, что он _является последовательностью_, потому, что он _ведёт себя_ как последовательность. *А только это и важно.*

Такой подход получил название *_"Динамическая типизация"_*. В оригинале используется термин *_"duck typing"_*.

=== Vector, попытка N2: последовательность допускающая срезку

.Реализация методов \\__len__ и \\__getitem__ для поддержки операций срезки
[source, python]
----
include::{sourcedir}/vector_nd_2.py[lines=1..30]
----

NOTE: Если мы хотим, что бы срезы `Vector` тоже были объектом класс `Vector`, то не должны делегировать получение среза классу `array`.

==== Как работает срезка

.Изучение поведения `\\__getitem__` и срезов
[source, python]
----
include::{sourcedir}/myseq.py[]
----

.Теперь приглядимся повнимательнее к `slice`:
[source, doctest]
----
>>> slice
<class 'slice'>
>>> dir(slice)
['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'indices', 'start', 'step', 'stop']
----


NOTE: `slice.indices` -- возвращает "нормализованный" кортеж.

indices(...)
    S.indices(len) -> (start, stop, stride)

    Assuming a sequence of length len, calculate the start and stop
    indices, and the stride length of the extended slice described by
    S. Out of bounds indices are clipped in a manner consistent with the
    handling of normal slices.


==== Метод `\\__getitem__` с учётом срезов

.Не окончательная версия
[source, python]
----
include::{sourcedir}/vector_nd_2.py[lines=1..28]
----

.Реализация срезов
[source, python]
----
include::{sourcedir}/vectorv2.py[lines=1..34]
----

=== Vector, попытка N3: доступ к динамическим атрибутам.

Идея сводится к реализации метода `\\__getattr__` для создания атрибутов класса, которые будут обращаться к элементам вектора. (пр. `self.x -> self[0]`, `self.y -> self[1]`).

.Релизация методов для установки и получения динамических аттрибутов
[source, python]
----
include::{sourcedir}/vectorv2.py[lines=35..74]
----

Часто с методом `\\__getattr__` приходится писать `\\__setattr__`, что бы избежать несогласованного поведения объекта. Если бы мы решили допустить изменение компонент, то могли бы реализовать метод `\\__setitem__`, что бы можно было писать `v[0] = 1.1`, и (или) метод `\\__setattr__`, что бы работала конструкция `v.x = 1.1`. Но сам класс *Vector* должен оставаться неизменяемый, потому что далее мы собираемся сделать его хэшируемым.

=== Vector, попытка N4: хэширование и ускорение оператора `==`

.Релизация методов для установки и получения динамических аттрибутов
[source, python]
----
include::{sourcedir}/vectorv2.py[lines=75..103]
----

.Удивительная функция *zip*
TIP: Позволяет параллельно обходить 2 и более итерируемых объекта: она возвращает кортежи, которые можно распаковать в переменные, -- по одной для каждого входного объекта

.*zip* за работой
[source, doctest]
----
>>> zip(range(3), 'ABC') # zip возвращает генератор, который порождает кортежи по запросу
<zip object at 0x0000024C12157EC0>
>>> list(zip(range(3), 'ABC'))
[(0, 'A'), (1, 'B'), (2, 'C')]
>>> list(zip(range(3), 'ABC', [0.0, 0.1, 0.2]))
[(0, 'A', 0.0), (1, 'B', 0.1), (2, 'C', 0.2)]
>>> from itertools import zip_longest
# itertools.zip_longest подставляет вместо отсутствующих значений необязательный аргумент fillvalue. Поэтому генерирует кортежи пока не окажется исчерпанным самый длинный итерируемый объект. Функция zip напротив бы остановилась без предупреждения если бы закончился один из объектов.
>>> list(zip_longest(range(3), 'ABC', [0.0, 0.1, 0.2, 0.3], fillvalue=666))
[(0, 'A', 0.0), (1, 'B', 0.1), (2, 'C', 0.2), (666, 666, 0.3)]
----

=== Vector, попытка N5: форматирование.

Можно взять метод форматирования из 2D вектора, но взамен подсчёта полярных координат, мы будем использовать _"гиперсферические"_ координаты (название связанно с тем, что в пространствах размерностью больше 4 и выше сферы называются гиперсферами). Соответственно специальный суффикс форматной строки `p` мы заменним на `h`.

Для объекта Vector в 4D пространстве код `h` порождает представление вида `<r, Ф1, Ф2, Ф3>`, где:

* *r* -- модуль вектора

* *Ф1, Ф2, Ф3* - угловые координаты

.Релизация метода формат для отображения в гиперсферических координатах
[source, python]
----
include::{sourcedir}/vectorv2.py[lines=104..165]
----

