include::./.asciidoctor/.asciidoctorconfig[]

== Глава 6. Реализация паттернов проектирования с помощью полноправных функций.

=== Практический пример: переработка паттерна Стратегия.

.В книге "Паттерны проектирования" паттерн *Стратегия* описывается следующим образом:
TIP: Определить семейство алгоритмов, инкапсулировать каждый из них и сделать их взаимозаменяемыми. Стратегия позволяет заменять алгоритмы независимо от использующих его клиентов.

Наглядный пример применения паттерна Стратегия к коммерческой задаче -- вычисление скидок на заказы в соответствии с характеристиками заказчика или результатами анализа заказанных позиций.
Рассмотрим интернет-магазин со следующими правилами формирования скидок:

* Заказчику, имеющему не менее 1000 баллов лояльности, предоставляется глобальная скидка `5%` на весь заказ;
* На позиции, заказанные в количестве не менее 20 штук, предоставляется скидка `10%`
* На заказы, содержащие не мене 10 различных позиций, предоставляется глобальная скидка `7%`

Для простоты предложим, что к каждому заказчику может быть применена только одна скидка.

.UML-диаграмма классов для обработки заказов
[ditaa]
....
     контекст -\      стратегия -\
     /---------/           /-----/
     :                     :
     V                     V
+---------+          +------------+
| Order   |--------->| Promotion  |
+---------+          +------------+
+---------+          +------------+
| total() |          | discount() |
| due()   |          +------------+
+---------+                ^
                           |
                           |
        /------------------+-------------------\
        |                  |                   |
        |                  |                   |
+-------+-------+  +-------+-------+  +--------+--------+
| FidelityPromo |  | BulkItemPromo |  | LargeOrderPromo |
+---------------+  +---------------+  +-----------------+
+---------------+  +---------------+  +-----------------+
| discount()    |  | discount()    |  | discount()      |
+---------------+  +---------------+  +-----------------+
       ^                  ^                   ^
       :                  :                   :
       \------------------+-------------------/
                          |
                  конкретные стратегии
....

.Контекст
NOTE: Представляет службу, делегируя часть вычислений взаимозаменяемым компонентам, реализующих различные алгоритмы. В примере Интернет-магазина контекстом является класс `Order`, который конфигурируется для применения поощрительной скидки по одному из нескольких алгоритмов.

.Стратегия
NOTE: Интерфейс, общий для всех компонентов, реализующих различные алгоритмы. В нашем примере эту роль играет абстрактный класс `Promotion`.

.Конкретные стратегии
NOTE: Один из конкретных подклассов Стратегии. В нашем примере реализованы три конкретные стратегии: `FidelityPromo`, `BulkItemPromo`, `LargeOrderPromo`.

В нашем примере система, перед тем как создать объект заказ, должна каким-то образом определит стратегию предоставления скидки и передать ее конструктору класса `Order`.
Вопрос о выборе стратегии не является предметом данного паттерна.


.Реализация класса `Order` с помощью взаимозаменяемых стратегий
[source, python]
----
include::{sourcedir}/strategy_2.py[]
----

Пример работает без нареканий, но ту же функциональность можно реализовать в Python гораздо короче, воспользовавшись функциями как объектами.

=== Функционально-ориентированная стратегия.

Каждая конкретная стратегия в примере -- это класс с одним методом `discount`. Сильно напоминают функции.
В следующем примере код переработан -- конкретные классы заменены функциями, а абстрактный класс `Promo` исключен


.Класс `Order`, в котором реализован в виде функций
[source, python]
----
include::{sourcedir}/strategy_3.py[]
----

=== Выбор наилучшей стратегии: простой подход

.Реализация функции выбора наилучшая стратегии
[source, python]
----
include::{sourcedir}/strategy_4.py[]
----

Фишка в том что бы воспринимать функцию как объект, который можно передавать в виде параметра.

WARNING: В данном коде возможна тонка ошибка. При написании новой стратегии, возможно забыть добавить её в список `promos`.


=== Поиск стратегии в модуле

NOTE: `globals()` - возвращает словарь, представляющий текущую таблицу глобальных символов. Это всегда словарь текущего модуля.

.Список promos строится путем перебора глобального пространства имен
[source, python]
----
include::{sourcedir}/startegy_5.py[]
----


=== Паттерн Команда

NOTE: Цель *Команды* - разорвать связь между объектом, инициировавшим операцию (Инициатором) и объектом, который её реализует (Получатель).

В примере Инициаторы - это пункты меню в графическом редакторе, а Получателем - редактируемый документ или само приложении.

.UML-диаграмма классов для управляемого меню текстового редактора, реализованного с помощью паттерна Команда. У каждой команды может быть свой получатель: объект, выполняющий действие. Для команды `PasteCommand` получателем является `Document`, а для `OpenCommand`- приложение.
[ditaa]
....
    клиент              инициатор             команда
       :                    :                     :
      //                   //                    //
      |                    |                     |
      |                    |                     V
      V                    V               +-----------+
+-------------+        +------+            |  Command  |
| Application |        | Menu +*---------->|-----------|<----------------------\
+-------------+        +------+            |-----------|                       |
   ^   ^                                   | execute() |                       |
   |   |                                   +-----------+                       |
   |   |                                         ^                             |
   |   |                                         |                             |
   |   |                       /-----------------+-----------------\           |
   |   |                       |                 |                 |           |
   |   |               +-------+------+  +-------+-------+ +-------+-------+   |
   |   \---------------+ OpenCommand  |  | PasteCommand  | | MacroCommand  +*--/
   :                   |--------------|  |---------------| |---------------|
   |                   |--------------|  |---------------| |---------------|
   |                   | execute()    |  | insert_text() | | execute()     |
   |                   +--------------+  +-------+-------+ +---------------+
   |                                             |
   |                                             V
   |                                     +-------+-------+
   +Получатели -=----------------------> | Document      |
                                         |---------------|
                                         |---------------|
                                         | insert_text() |
                                         +---------------+
....

Идея в том, что бы между инициатором и исполнителем поместить объект `Command`, который реализует интерфейс с одним
методом `execute()`, вызывающим какой-то метод Получателя для выполнения желаемой операции. Таким образом, Инициатор
ничего не знает об интерфейсе Получателя, так что, написав подкласс `Command`, можно адаптировать различные получатели.
Инициатор конфигурируется конкретной командой и вызывает ее метод `execute`.

TIP: Класс `MacroCommand`, который может содержать последовательность команд; его метод `execute()` вызывает одноименные методы каждой хранимой команды.

Вместо передачи объекта `Command`, мы можем передать обычную функцию. Реализовать можно через специальный метод `\\__call__`.

Тогда `MacroCommand` будут вызываемыми объектами, содержащими список функций для последующего вызова.

[source, python]
----
include::{sourcedir}/macrocommand.py[]
----

=== Ссылочки и дополнительные материалы

* http://bit.ly/1HGC0r5[Паттерны поректирования в динамических языках.]


[source, python]
----
include::{sourcedir}/strategy.py[]
----
