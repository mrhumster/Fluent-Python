include::./.asciidoctor/.asciidoctorconfig[]

== Глава 14. Итерируемые объекты, итераторы и генераторы.

Итерирование -- одна из важнейших операций обработки данных. А если просматривается набор данных, не помещающийся целиком в память, то нужен способ выполнять её _отложенно_, т.е. по одному элементу и по запросу. Именно в этом смысл паттерна *Итератор*.

Ключевое слово *yield* (_появилось только в Py >= 2.2_) позволяет конструировать генераторы, которые работают как итераторы.

TIP: Любой генератор является итератором: генераторы используют весь интерфейс итераторов. Но итератор -- в том виде, как он определён в книге "Банды четырёх", -- извлекает элементы из коллекции, тогда как генератор может порождать элементы "из воздуха". Типичным примером является генератор чисел Фибоначчи -- бесконечно последовательности, которую нельзя сохранить в коллекции. Однако, надо иметь в виду, что в сообществе Python слова _итератор_ и _генератор_ обычно употребляется как синонимы.

=== Класс Sentence, попытка № 1: Последовательность слов.

В примере представлен класс `Sentence`, который умеет извлекать из текста слово с заданным индексом.

.`sentence.py`: объект `Sentence` как последовательность слов
[source, python]
----
include::{sourcedir}/sentence.py[]
----

Всякий раз когда интерпретатору нужно обойти объект `x`, он автоматически вызывает функцию `iter(x)`.

Встроенная функция `iter(x)` выполняет следующие действия.

1. Смотрим, реализует ли объект метод `\\__iter__`, и если да, вызывает его, что бы получить итератор.

2. Если метод `\\__iter__` не реализован, но реализован метод `\\__getitem__`, то Python создает итератор, который пытается извлекать элементы по порядку, начиная с индекса 0.

3. Если и это не получается, то возбуждает исключение -- обычно с сообщением `_C_ object is not iterable`, где _C_ -- класс объекта.

.`sentence_iter.py`:  класс `Sentence`, реализован с помощью паттерна Итератор
[source, python]
----
include::{sourcedir}/sentence_iter.py[]
----

.`sentence_gen.py`:  класс `Sentence`, реализован с помощью паттерна Генератора
[source, python]
----
include::{sourcedir}/sentence_gen.py[]
----


=== Как работает генераторная функция


NOTE: Любая функция Python, в теле которой встречается слово `yield`, называется генераторной функцией -- при вызове она возвращает объект-генератор.


.`sentence_gen2.py`:  класс `Sentence`, реализован с помощью паттерна Генератора
[source, python]
----
include::{sourcedir}/sentence_gen2.py[]
----


NOTE: Генераторные функции -- замечательный способ сократить код, но генераторные выражения ещё круче.

Простые генераторные функции наподобие той, что мы использовали в предыдущем варианте класса `Sentence`, можно заменить _генераторным выражением_.

Можно считать что генераторное выражение -- ленивая версия спискового включения: она не строит список энергично, а возвращает генератор, который лениво порождает элементы по запросу.

.Генераторная функция `gen_AB` используется сначала в списковом включении, а затем в генераторном выражении.
[source, doctest]
----
>>> def gen_AB():
...     print('start')
...     yield 'A'
...     print('continue')
...     yield 'B'
...     print('end.')
...
>>> res1 = [x*3 for x in gen_AB()] # Списковое включение энергично обходит элементы, порождаемые объектом-генератором, который был создан функцией gen_AB.
start
continue
end.
>>> for i in res1:
...     print('-->', i)
...
--> AAA
--> BBB
>>> res2 = (x*3 for x in gen_AB())
>>> res2
<generator object <genexpr> at 0x0000020BAC482C00>
>>> for i in res2:
...     print('-->', i)
...
start
--> AAA
continue
--> BBB
end.
----

Таким образом, генераторное выражение порождает генератор, и мы можем этим воспользоваться что бы ещё сократить размер класса Sentence.

.`sentence_genexp.py`: реализация класса `Sentence` с помощью генераторного выражения.
[source, python]
----
include::{sourcedir}/sentence_genexp.py[]
----

Генераторные выражения - это не более чем синтаксическая глазурь: их всегда можно заменить генераторными функциями.

=== Построение арифметической прогреcсии


[source, python]
----
include::{sourcedir}/aritprog_gen.py[]
----

=== Построение арифметической прогрессии с помощью `itertools`

TIP: Функция `itertools.count` возвращает генератор, порождающий числа. Без аргументов порождает ряд целых начиная с 0. А если задать аргументы `start` и `step`, то получится результат схожий с тем, что дает функция `aritprog_gen`

Однако `itertools.count` никогда не останавливается.

TIP: `itertools.takewhile` - порождает генератор, который потребляет другой генератор и останавливается, когда заданный предикат станет равен `False`.


[source, doctest]
----
>>> import itertools
>>> gen = itertools.takewhile(lambda n: n<3, itertools.count(1, .5))
>>> list (gen)
[1, 1.5, 2.0, 2.5]
----


.`aritprog_v3.py`: работает так же как и `aritprog_gen.py`
[source, python]
----
include::{sourcedir}/aritprog_v3.py[]
----

=== Генераторные функции в стандартной библиотеке

.Фильтрующие генераторные функции
|===
|Модуль |Функция |Описание

.2+^.^|`itertools`
^.^|`compress(it, selector_it)`
|Потребляет параллельно два итерируемых объекта; отдает элемент `it`, когда соответствующий `selector_it` принимает истинное значение.


^.^|`dropwhile(predicate, it)`
|Потребляет `it`, пропуская элементы, пока `predicate` принимает похожее на истину значение, а затем отдает все оставшиеся элементы (больше никаких проверок не делает)

^.^|встроенная
^.^|`filter(predicate, it)`
|Применяет предикат к каждому элементу итерируемого объекта, отдавая элемент, если `predicate(item)` принимает похожее на истину значение; если `predicate` равен `None`, отдаются только элементы, принимающие похожее значение.

.3+^.^|`itertools`
^.^|`filterfalse(predicate, it)`
|То же, что `filter`, но логика инвертирована: отдаются элементы, для которых предиката принимает похожее на ложь значение.


^.^|`islice(it, stop)` или `islice(it, start, stop, step=1)`
|Отдает элементы из среза `it` по аналогии с `s[:stop]` или `s[start:stop:step]`, только `it` может быть произвольным итерированным объектом, а операция ленивая.


|`takewhile(predicate, it)`
|Отдает элементы, пока `predicate` принимает похожее на истину значение, затем останавливается, больше никаких проверок не делается.
|===

.Примеры фильтрующих генераторных функций
[source,doctest]
----
>>> def vowel(c):
...     return c.lower() in 'aeiou'
>>> list(filter(vowel, 'Aardvark'))
['A', 'a', 'a']
>>> import itertools
>>> list(itertools.filterfalse(vowel, 'Aardvark'))
['r', 'd', 'v', 'r', 'k']
>>> list(itertools.dropwhile(vowel, 'Aardvark'))
['r', 'd', 'v', 'a', 'r', 'k']
>>> list(itertools.takewhile(vowel, 'Aardvark'))
['A', 'a']
>>> list(itertools.compress('Aardvark', (1,0,1,1,0,1)))
['A', 'r', 'd', 'a']
>>> list(itertools.islice('Aardvark', 4))
['A', 'a', 'r', 'd']
>>> list(itertools.islice('Aardvark', 4, 7))
['v', 'a', 'r']
>>> list(itertools.islice('Aardvark', 1, 4, 7))
['a']
>>> list(itertools.islice('Aardvark', 1, 7, 2))
['a', 'd', 'a']
----

.Отображающие генераторные функции
|===
|Модуль |Функция |Описание

^.^|`itertools`
^.^|`accumulate(it, [func])`
|Отдает накопленные суммы; если задана функция `func`, то отдает результат, применяя её к первой паре элементов, затем к первому результату и следующему элементу и т.д.

.2+^.^|встроенная
^.^|`enumerate(iterable, start=0`
|Отдает 2-кортежи вида `(index, item)`, где `index` начинается со значения `start`, а `item`, извлекается из `iterable`.

^.^|`map(func, it1, [it2, ..., itN])`
|Применяет `func` к каждому элементу `it` и отдает результат; если задано `N` итерируемых объектов, то `func` должна принимать `N` итерируемых объектов, и все итерируемые объекты обходятся параллельно.

^.^|`itertools`
^.^|`starmap(func, it)`
|Применяет `func` к каждому элементу `it` и отдает результат; входной итерируемый объект должен отдавать итерируемые объекты `iit`, а `func` вызывается в виде `func(*iit)`
|===

.Примеры применения генераторной функции `itertools.accumulate`
[source,doctest]
----
>>> sample = [5, 4, 2, 8, 7, 6, 3, 0, 9, 1]
>>> list(itertools.accumulate(sample)) # Частичные суммы.
[5, 9, 11, 19, 26, 32, 35, 35, 44, 45]
>>> list(itertools.accumulate(sample, min)) # Частичные минимумы.
[5, 4, 2, 2, 2, 2, 2, 0, 0, 0]
>>> list(itertools.accumulate(sample, max)) # Частичные максимумы.
[5, 5, 5, 8, 8, 8, 8, 8, 9, 9]
>>> import operator
>>> list(itertools.accumulate(sample, operator.mul)) # Частичные произведения.
[5, 20, 40, 320, 2240, 13440, 40320, 0, 0, 0]
>>> list(itertools.accumulate(range(1, 11), operator.mul)) # Факториалы от 1! до 10!.
[1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]
----

.Примеры применения отображающих генераторных функций
[source, doctest]
----
>>> list(enumerate('XOMRKOB', 1))
[(1, 'X'), (2, 'O'), (3, 'M'), (4, 'R'), (5, 'K'), (6, 'O'), (7, 'B')]
>>> list(map(operator.mul, range(11), range(11))) # Квадраты целых чисел от 0 до 10
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
>>> list(map(operator.mul, range(11), [2, 4, 8])) # Перемножение целых чисел из двух параллельных итерируемых объектов; операция заканчивается, когда будет достигнут конец более короткого объекта.
[0, 4, 16]
>>> list(map(lambda a, b: (a, b), range(11), [2, 4, 8])) # То же самое делает встроенная функция zip
[(0, 2), (1, 4), (2, 8)]
>>> list(itertools.starmap(operator.mul, enumerate('albatroz', 1))) # Повторение каждой буквы слова, столько раз, каков номер ее позиции
['a', 'll', 'bbb', 'aaaa', 'ttttt', 'rrrrrr', 'ooooooo', 'zzzzzzzz']
>>> sample = [5, 4, 2, 8, 7, 6, 3, 0, 9, 1]
>>> list(itertools.starmap(lambda a, b: b/a, enumerate(itertools.accumulate(sample), 1))) # Частичное среднее 😵
[5.0, 4.5, 3.6666666666666665, 4.75, 5.2, 5.333333333333333, 5.0, 4.375, 4.888888888888889, 4.5]
----

|===
|Модуль |Функция |Описание

.3+^.^|`itertools`
^.^|`chain(it1, ..., itN)`
|Отдает все элементы из `it1`, затем из `it2` и т.д.

^.^|`chain.from_iterable(it)`
|Отдает все элементы из каждого итерируемого объекта, порождаемого `it`, перебирая их один за другим; `it` должен порождать итерируемые объекты, например это может быть список итерируемых объектов.

^.^|`product(it1, ..., itN, repeat=1)`
|Декартово произведение: отдает N-кортежи, полученные путём комбинирования элементов из каждого входного итерируемого объекта,- так, как это делалось бы с помощью вложенных циклов `for`; аргумент `repeat` позволяет обходить входные итерируемые объекты больше одного раза.

^.^|встороенная
^.^|`zip(it1, ..., itN)`
|Отдает N-кортежи, построенные из элементов, которые берутся параллельно из входных итерируемых объектов; операция прекращается по исчерпанию самого короткого итерируемого элемента.

^.^|`itertools`
^.^|`zip_longest(it1, ..., itN, fillvalue=None)`
|Отдает N-кортежи, построенные из элементов, которые берутся параллельно из входных итерируемых объектов; операция прекращается по исчерпанию самого длинного итерируемого элемента, а вместо недостающих элементов подставляется значение `fillvalue`.
|===

.Примеры применения объединяющих генераторных функций
[source, doctest]
----
>>> list(itertools.chain('ABC', range(2))) # chain обычно вызывается с 2мя и более итерируемых объектов
['A', 'B', 'C', 0, 1]
>>> list(itertools.chain(enumerate('ABC'))) # При вызове с одним элементом, chain не делает ничего полезного
[(0, 'A'), (1, 'B'), (2, 'C')]
>>> list(itertools.chain.from_iterable(enumerate('ABC'))) # chain.from_iterable берёт каждый элемент из итерируемого объекта и сцепляет их в последовательность, при условии, что каждый элемент является итерируемым объектом
[0, 'A', 1, 'B', 2, 'C']
>>> list(zip('ABC', range(5)))
[('A', 0), ('B', 1), ('C', 2)]
>>> list(zip('ABC', range(5), [10, 20, 30, 40]))
[('A', 0, 10), ('B', 1, 20), ('C', 2, 30)]
>>> list(itertools.zip_longest('ABC', range(5), [10, 20, 30, 40]))
[('A', 0, 10), ('B', 1, 20), ('C', 2, 30), (None, 3, 40), (None, 4, None)]
----

