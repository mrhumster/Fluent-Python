include::./.asciidoctor/.asciidoctorconfig[]

== Глава 9. Объекты в духе Python

=== Представление объекта

* `repr()` -- вернуть строку, представляющую объект в виде, удобном для разработчика.

* `str()` -- вернуть строку, представляющую объект в виде, удобном для пользователя.

NOTE: Для поддержки repr и str мы должны реализовать методы `\\__repr__` и `\\__str__`. Существует еще  два специальным метода для поддержки альтернативных представлений объектов `\\__bytes__` и `\\__format__`

=== И снова класс вектора

.class Vector2d. Пока, что реализованы только спеиальные методы
[source, python]
----
include::{sourcedir}/vector2d_v0.py[]
----

.У экземпляров Vector2d есть несколько представлений.
[source, doctest]
----
include::{doctestdir}/vector2d_v0.txt[]
----

CAUTION: Метод `\\__eq__` работает для операндов типа Vector2d, но возвращает True и
в случае, когда экземпляр Vector2d сравнивается с другими итерируемыми объектами,
содержащими точно такие же числовые значения (например `Vector(3, 4) == [3, 4]`).
Считать ли это ошибкой или нет, зависит от точки зрения.

У нас имеется довольно полный набор базовых методов, но одного не хватает: восстановления объекта Vector2d из двоичной последовательности, порожденного функцией bytes.

=== Альтернативный конструктор

.Добавлен метод класса frombytes
[source, python]
----
include::{sourcedir}/vector2d_v1.py[]
----

.Пример использования альтернативного конструктора
[source, doctest]
----
include::{doctestdir}/vector2d_v0.txt[]
----

=== Декораторы `classmethod` и `staticmethod`

TIP: `@classmethod` -- определяет метод на уровне класса, а не отдельного экземпляра. Данный декоратор изменяет способ вызова метода таким образом, что в качестве первого аргумента передается сам класс, а не экземпляр. Типичное применение -- альтернативные конструкторы, подобные `frombytes` из примера выше.

TIP: `@staticmethod` -- изменяет метод так, что он не получает в первом аргументе ничего специального. По существу, статический метод -- это просто обычная функция, определенная в теле класса, а не на уровне модуля.

.Метод `\\__format__` позволяет расширить мини-язык форматирования. В нашем случае возможность вывода вектора в полярных координатах.
[source, doctest]
----
include::{doctestdir}/vector2d_fmt.txt[]
----

=== Хэшируемый класс Vector2d

До сих пор класс Vector2d не был хэшируемым и мы не могли поместить его во множество.

Что бы класс стал хэшируемым необходимо реализовать метод `\\__hash__`

TIP: Необходим еще метод `\\__eq__`, но он у нас уже есть.

Нужно сделать класс не изменяемым. Мы добьемся этого сделав `x` и `y` аттрибутами только на чтение.

.Пример реализации закрытых свойств
[source, python]
----
include::{sourcedir}/vector2d_v3.py[lines=1..25]
----

Теперь когда вектор не изменяемый, мы должны реализовать `\\__hash__`.

.Пример реализации метода хэширования.
[source, python]
----
include::{sourcedir}/vector2d_v3.py[lines=26..]
----

NOTE: В рекомендациях по специальному методу `\\__hash__` (https://docs.python.org/3/reference/datamodel.html#object.\\__hash__[3.10.1 Documentation » The Python Language Reference » 3. Data model]) рекомендуется объединять хэши компонентов при помощи поразрядного оператора *ИСКЛЮЧАЮЩЕЕ ИЛИ* (^)

=== Экономия памяти с помощью аттрибута `\\__slots__`

.Определяя в классе аттрибут \\__slots__ мы говорим интерпретатору: "Это все аттрибуты экземпляра в данном классе"
[source, python]
----
include::{sourcedir}/vector2d_v3.py[lines=4..5]
----

NOTE: Тогда Python помещает их в кортеже-подобную структуру в каждом экземпляре, что позволяет избежать накладных рассходов по использованию словаря `\\__dict__`

