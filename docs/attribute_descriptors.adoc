:icons: font

== Глава 20. Дескрипторы атрибутов

"Изучение дескрипторов  не только расширяет доступный инструментарий, но позволяет глубже понять, как работает Python, и оценить элегантность его дизайнаfootnote:[Raymond Hettinger https://docs.python.org/3/howto/descriptor.html["Descriptor HowTo Guide"]]."
-- Раймонд Хэттигер, один из разработчиков Python и гуру

NOTE: Дескрипторы -- это способ повторного использования одной и той же логики доступа в нескольких атрибутах. Например, типы полей в ОО отображениях типа Django ORM и SQL Alchemy -- дескрипторы, управляющие потоком данных от полей в записи БД к атрибутам Python-объекта и обратно.

TIP: Десериптор -- это класс, который реализует протокол, содержащий  методы `\\__get__`, `\\__set__` и `\\__delete__`. Класс `property` реализует весь протокол дескриптора. Как обычно, разрешается реализовывать протокол частично. На самом деле, большинство дескрипторов, встречающихся в реальных программах, реализуют только методы `\\__get__` и `\\__set__`, а многие -- и вовсе лишь один из них.

=== Пример дескриптора: проверка значений атрибутов

Фабрика свойств -- это функция высшего порядка, которая создает параметризованный набор функций-акцессоров. Она строит из них экземпляры конкретных свойств, настройки которых, например `storage_name`, хранятся в замыканиях. ОО способ решения той же задачи -- дескрипторный класс.

Мы вернёмся к примеру класса `LineItem` с того места, где остановились, и переделаем фабрику свойств `quantity` в дескрипторный класс `Quantity`.

==== `LineItem` попытка №3: простой дескриптор

Класс, в котором реализован хотя бы один из методов `\\__get__`, `\\__set__` или `\\__delete__`, является дескриптором. Для использования дескриптора мы объявляем его экземпляром атрибута какого-то другого класса.

Мы создадим дескриптор `Quantity` и включим в класс `LineItem` два экземпляра `Quantity`: для управления атрибутами `wight` и `price`. Всё это изображено на диаграме классов.


.UML-диаграмма класса `LineItem` и используемого в нём дескрипторного класса `Quantity`
[plantuml, format=png, align=center]
....
@startuml
class Quantity <<description>> {
    {field} storage_name:
    {method} __init__
    {method} __set__
}

note top of Quantity
дескрипторный класс
end note

class LineItem {
    {field} description
    {field} weight {storage}
    {field} price {storage}
    {method} __init__
    {method} subtotal
}

note top of LineItem
управляемый класс
end note

Quantity <-* LineItem: weight
Quantity <-* LineItem: price
Quantity -[dotted]-> LineItem: get and set managed attribute

@enduml
....

.Дескрипторный класс
Класс, реализующий протокол дескриптора. Это класс `Quantity`.

.Управляемый класс
Класс, в котором атрибуты класса, являющиеся экземпляром дескриптора. Это класс `LineItem`.

.Экземпляр дескриптора
Любой экземпляр дескрипторного класса, объявленный атрибутом класса в управляемом классе.

.Управляемый экземпляр
Один экземпляр управляемого класса.

.Атрибуты хранения
Атрибуты управляемого экземпляра, в котором хранится значение управляемого атрибута для данного экземпляра.

.Управляемый атрибут
Открытый атрибут управляемого класса, который обрабатывается экземпляром дескриптора, а значение которого хранится в одном из атрибутов хранения. Другими словами, экземпляр дескриптора и атрибут хранения в совокупности образуют инфраструктуру для управляемого атрибута.

.`bulkfood_v3.py`: дескриптор `Quantity` управляют атрибутами `LineItem`.
[source, python]
----
include::../source/bulkfood_v3.py[]
----

WARNING: Кодируя метод `\\__set__`, не забывайте, что означают аргументы `self` и `instance`: `self` -- это экземпляр дескриптора, а `instance` -- управляемый экземпляр. Дескрипторы, управляющие атрибутами экземпляра, должны хранить значения в управляемых экземплярах. Поэтому-то Python и передаёт аргумент `instance` методам дескриптора.


Может возникнуть соблазн хранить значения всех управляемых атрибутов в экземпляре самого дескриптора, т.е. в методе `\\__set__` вместо кода

`instance.\\__dict__[self.storage_name] = value`

написать:

`self.\\__dict__[self.storage_name] = value`

Но это совершенно неправильно! Одновременно в памяти могут находиться тысячи экземпляров `LineItem`, но экземплярова дескриптора будет только 2: `LineItem.weight`, `LineItem.price`.

В примере есть недостаток: повторяющиеся имена атрибутов. Хорошо было бы использовать `LineItem` как-то так:

[source, python]
----
class LineItem:
    weight = Quantity()
    price = Quantity()
...
----

Проблема в том, что правая часть присваивания вычисляется ещё до того, как начинает существовать переменная.

==== `LineItem` попытка №4: автоматическая генерация имен атрибутов хранения

.Теперь в классе `Quantity` есть оба метода `get` и `set`, а в экземплярах `LineItem` -- атрибуты хранения со сгенерированными именами: `_Quantity#0` и `_Quantity#1`
[plantuml, format=png, align=center]
....
include::../docs/LineItem.puml[]
....

Для генерации `storage` мы берём общий префикс `_Quantity#` и добавляем у нему целое число: текущее значение атрибута класса `Quantity.__counter`, которое увеличивается на единицу всякий раз, как к классу присоединяется новый экземпляр дескриптора `Quantity`. Знак решётки гарантирует, что `storage_name` не совпадает с именем, созданным в результате применения пользователем нотации с точкой, поскольку `nutmeg._Quantity#0` -- недопустимый идентификатор в Python.

.`bulkfood_v4.py`: каждый дескриптор `Quantity` получает уникальное имя `storage_name`.
[source, python]
----
include::../source/bulkfood_v4.py[]
----

TIP: Здесь мы можем использовать высокоуровневые функции `getattr` и `setattr` для чтения и сохранения значения, а не манипулировать напрямую `instance.\\__dict__`, потому что имена управляемого атрибута и атрибута хранения различны, а, значит, вызов `getattr` для атрибута хранения не приведет к вызову дескриптора и бесконечной рекурсии, как в примере ранее, не возникает.

.`bulkfood_v4b.py`: при вызове через управляемый класс метод `\\__get__` возвращает ссылку на сам дескриптор
[source, python]
----
include::../source/bulkfood_v4b.py[lines=1..25]
----

[source, doctest]
----
>>> from bulkfood_v4 import LineItem
>>> LineItem.weight
Traceback (most recent call last):
...
    return getattr(instance, self.storage_name)
AttributeError: 'NoneType' object has no attribute '_Quantity#0'
----

.Результат выполнения примера
[source, doctest]
----
>>> from bulkfood_v4b import LineItem
>>> LineItem.weight
<bulkfood_v4b.Quantity object at 0x7f707597f010>
----

При взгяде на пример возникает чувство, что уж слишком много кода, для управления всего двумя аттрибутами, однако важно понимать, что логика дескриптора вынесена в отдельную единицу кода: класс `Quantity`. Обычно дескриптор определяется не в том же модуле, где используется, а в отдельном служебном модуле, который предназнаяен для использования в разных местах приложения и даже в разных приложениях, если разрабатывается каркас.

.`bulkfood_v4prop.py`: та же функциональность, но реализованная в виде фабрики свойств, а не дескрипторного класса.
[source, python]
----
include::../source/bulkfood_v4prop.py[]
----

Ну и что вы предпочтёте? Я предпочитаю подход на основе класса в основном по двум причинам:

* дескрипторный класс можно расширять посредством наследования; повторно использовать код фабричной функции без копирования и вставки гораздо труднее;

* хранить состояние в атрибутах класса и экземпляров проще, чем в атрибутах функции и замыканий.

Короче говоря, паттерн фабрики свойств в некоторых отношениях проще, но дескрипторный класс лучше обобщается. И используется последний подход шире.

=== `LineItem` попытка №5: новый тип дескриптора

