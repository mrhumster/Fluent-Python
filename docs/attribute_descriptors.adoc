:icons: font

== Глава 20. Дескрипторы атрибутов

"Изучение дескрипторов  не только расширяет доступный инструментарий, но позволяет глубже понять, как работает Python, и оценить элегантность его дизайнаfootnote:[Raymond Hettinger https://docs.python.org/3/howto/descriptor.html["Descriptor HowTo Guide"]]."
-- Раймонд Хэттигер, один из разработчиков Python и гуру

NOTE: Дескрипторы -- это способ повторного использования одной и той же логики доступа в нескольких атрибутах. Например, типы полей в ОО отображениях типа Django ORM и SQL Alchemy -- дескрипторы, управляющие потоком данных от полей в записи БД к атрибутам Python-объекта и обратно.

TIP: Десериптор -- это класс, который реализует протокол, содержащий  методы `\\__get__`, `\\__set__` и `\\__delete__`. Класс `property` реализует весь протокол дескриптора. Как обычно, разрешается реализовывать протокол частично. На самом деле, большинство дескрипторов, встречающихся в реальных программах, реализуют только методы `\\__get__` и `\\__set__`, а многие -- и вовсе лишь один из них.

=== Пример дескриптора: проверка значений атрибутов

Фабрика свойств -- это функция высшего порядка, которая создает параметризованный набор функций-акцессоров. Она строит из них экземпляры конкретных свойств, настройки которых, например `storage_name`, хранятся в замыканиях. ОО способ решения той же задачи -- дескрипторный класс.

Мы вернёмся к примеру класса `LineItem` с того места, где остановились, и переделаем фабрику свойств `quantity` в дескрипторный класс `Quantity`.

==== `LineItem` попытка №3: простой дескриптор

Класс, в котором реализован хотя бы один из методов `\\__get__`, `\\__set__` или `\\__delete__`, является дескриптором. Для использования дескриптора мы объявляем его экземпляром атрибута какого-то другого класса.

Мы создадим дескриптор `Quantity` и включим в класс `LineItem` два экземпляра `Quantity`: для управления атрибутами `wight` и `price`. Всё это изображено на диаграме классов.


.UML-диаграмма класса `LineItem` и используемого в нём дескрипторного класса `Quantity`
[plantuml, format=png, align=center]
....
@startuml
class Quantity <<description>> {
    {field} storage_name:
    {method} __init__
    {method} __set__
}

note top of Quantity
дескрипторный класс
end note

class LineItem {
    {field} description
    {field} weight {storage}
    {field} price {storage}
    {method} __init__
    {method} subtotal
}

note top of LineItem
управляемый класс
end note

Quantity <-* LineItem: weight
Quantity <-* LineItem: price
Quantity -[dotted]-> LineItem: get and set managed attribute

@enduml
....

.Дескрипторный класс
Класс, реализующий протокол дескриптора. Это класс `Quantity`.

.Управляемый класс
Класс, в котором атрибуты класса, являющиеся экземпляром дескриптора. Это класс `LineItem`.

.Экземпляр дескриптора
Любой экземпляр дескрипторного класса, объявленный атрибутом класса в управляемом классе.

.Управляемый экземпляр
Один экземпляр управляемого класса.

.Атрибуты хранения
Атрибуты управляемого экземпляра, в котором хранится значение управляемого атрибута для данного экземпляра.

.Управляемый атрибут
Открытый атрибут управляемого класса, который обрабатывается экземпляром дескриптора, а значение которого хранится в одном из атрибутов хранения. Другими словами, экземпляр дескриптора и атрибут хранения в совокупности образуют инфраструктуру для управляемого атрибута.

.`bulkfood_v3.py`: дескриптор `Quantity` управляют атрибутами `LineItem`.
[source, python]
----
include::../source/bulkfood_v3.py[]
----

WARNING: Кодируя метод `\\__set__`, не забывайте, что означают аргументы `self` и `instance`: `self` -- это экземпляр дескриптора, а `instance` -- управляемый экземпляр. Дескрипторы, управляющие атрибутами экземпляра, должны хранить значения в управляемых экземплярах. Поэтому-то Python и передаёт аргумент `instance` методам дескриптора.


Может возникнуть соблазн хранить значения всех управляемых атрибутов в экземпляре самого дескриптора, т.е. в методе `\\__set__` вместо кода

`instance.\\__dict__[self.storage_name] = value`

написать:

`self.\\__dict__[self.storage_name] = value`

Но это совершенно неправильно! Одновременно в памяти могут находиться тысячи экземпляров `LineItem`, но экземплярова дескриптора будет только 2: `LineItem.weight`, `LineItem.price`.

В примере есть недостаток: повторяющиеся имена атрибутов. Хорошо было бы использовать `LineItem` как-то так:

[source, python]
----
class LineItem:
    weight = Quantity()
    price = Quantity()
...
----

Проблема в том, что правая часть присваивания вычисляется ещё до того, как начинает существовать переменная.

==== `LineItem` попытка №4: автоматическая генерация имен атрибутов хранения

.Теперь в классе `Quantity` есть оба метода `get` и `set`, а в экземплярах `LineItem` -- атрибуты хранения со сгенерированными именами: `_Quantity#0` и `_Quantity#1`
[plantuml, format=png, align=center]
....
include::../docs/LineItem.puml[]
....

Для генерации `storage` мы берём общий префикс `_Quantity#` и добавляем у нему целое число: текущее значение атрибута класса `Quantity.__counter`, которое увеличивается на единицу всякий раз, как к классу присоединяется новый экземпляр дескриптора `Quantity`. Знак решётки гарантирует, что `storage_name` не совпадает с именем, созданным в результате применения пользователем нотации с точкой, поскольку `nutmeg._Quantity#0` -- недопустимый идентификатор в Python.

.`bulkfood_v4.py`: каждый дескриптор `Quantity` получает уникальное имя `storage_name`.
[source, python]
----
include::../source/bulkfood_v4.py[]
----

TIP: Здесь мы можем использовать высокоуровневые функции `getattr` и `setattr` для чтения и сохранения значения, а не манипулировать напрямую `instance.\\__dict__`, потому что имена управляемого атрибута и атрибута хранения различны, а, значит, вызов `getattr` для атрибута хранения не приведет к вызову дескриптора и бесконечной рекурсии, как в примере ранее, не возникает.

.`bulkfood_v4b.py`: при вызове через управляемый класс метод `\\__get__` возвращает ссылку на сам дескриптор
[source, python]
----
include::../source/bulkfood_v4b.py[lines=1..25]
----

[source, doctest]
----
>>> from bulkfood_v4 import LineItem
>>> LineItem.weight
Traceback (most recent call last):
...
    return getattr(instance, self.storage_name)
AttributeError: 'NoneType' object has no attribute '_Quantity#0'
----

.Результат выполнения примера
[source, doctest]
----
>>> from bulkfood_v4b import LineItem
>>> LineItem.weight
<bulkfood_v4b.Quantity object at 0x7f707597f010>
----

При взгяде на пример возникает чувство, что уж слишком много кода, для управления всего двумя аттрибутами, однако важно понимать, что логика дескриптора вынесена в отдельную единицу кода: класс `Quantity`. Обычно дескриптор определяется не в том же модуле, где используется, а в отдельном служебном модуле, который предназнаяен для использования в разных местах приложения и даже в разных приложениях, если разрабатывается каркас.

.`bulkfood_v4prop.py`: та же функциональность, но реализованная в виде фабрики свойств, а не дескрипторного класса.
[source, python]
----
include::../source/bulkfood_v4prop.py[]
----

Ну и что вы предпочтёте? Я предпочитаю подход на основе класса в основном по двум причинам:

* дескрипторный класс можно расширять посредством наследования; повторно использовать код фабричной функции без копирования и вставки гораздо труднее;

* хранить состояние в атрибутах класса и экземпляров проще, чем в атрибутах функции и замыканий.

Короче говоря, паттерн фабрики свойств в некоторых отношениях проще, но дескрипторный класс лучше обобщается. И используется последний подход шире.

=== `LineItem` попытка №5: новый тип дескриптора

Описание товара в данном объекте может быть пустым. Это плохо. Что бы не допустить такого, создадим новый дескриптор, `NoneBlank`. Т.к. реализация дескриптора похожа на `Quantity`, есть смысл переделать всё. Данный класс делает две разные вещи: отвечает за работу с атрибутами в управляемых экземплярах и проверяет значения, записываемые в эти атрибуты.

Это наводит на мысль о рефакторинге и заведении двух базовых классов:

* `AutoStorage` -- Дескрипторный класс, который автоматически управляет атрибутами хранения.

* `Validate` -- Абстрактный подкласс `AutoStorage`, который переопределяет метод `\\__set__`, вызывая метод `validate`, который должен быть реализован в подклассах.

Далее мы переписываем `Quantity` и реализуем `NoneBlank`, наследуя классу `Validate`, так что остаётся лишь написать методы `validate`

.Иерархия дескрипторных классов. Базовый класс `AutoStorage` автоматически управляет атрибутами хранения, а `Validate` производит проверку, делегируя работу абстрактному методу `validate`. `Quantity` и `NonBlank` - конкретные подклассы `Validated`.
[plantuml, format=png, align=center]
....
include::../docs/LineItem_validate.puml[]
....

NOTE: Соотношение между классами `Validate`, `Quantity` и `NoneBlank` -- пример _паттерна проектирования_ *Шаблонный метод*. Конкретно, метод `Validated.\\__set__` -- типичный пример того, что "банда четырех" называет шаблонным методом: _Шаблонный метод определяет алгоритм в терминах абстракных операций, которые переопределяются в подклассах для обеспечения конкретного поведения_.

.`model_v5.py`: дескрипторные классы после рефакторинга.
[source, python]
----
include::../source/model_v5.py[]
----

Пользователям модуля `model_v5.py` все эти детали знать не обязательно. Важно лишь, что они получают возможность использовать классы `Quantity` и `NonBlank` для автоматизации проверки атрибутов экземпляра.

.`bulkfood_v5.py`: использование дескрипторов `Quantity` и `NoneBlank` в классе `LineItem`
[source, python]
----
include::../source/bulkfood_v5.py[]
----

Приведенные в этой главе вариант класса `LineItem` демонстрирует типичное применение дескрипторов для управления атрибутами-данными. Такой дескриптор называют ещё _переопределяющим_, поскольку его метод `\\__set__` переопределяет (т.е. перехватывает и подменяет) установку одноименного атрибута в управляемом экземпляре.

=== Переопределяющие и не переопределяющие дескрипторы

При чтении атрибута через экземпляр обычно возвращается атрибут, определенный в этом экземпляре, а если такого атрибута в экземпляре не существует, то атрибут класса. С другой стороны, в случае присваивания атрибуту экземпляра обычно создается атрибут в этом экземпляре, а класс вообще никак не затрагивается.

Эта асимметрия распространяется и на дескрипторы, в результате чего образуется две категории дескрипторов, различающиеся наличием или отсутствием метода `\\__set__`.

.`descriptorkinds.py`: простые классы для изучения поведения дескрипторов.
[source, python]
----
include::../source/descriptorkinds.py[]
----

NOTE: Объедены несколько подглав в одну. Там обсуждались doc-тесты и поведение дескрипторов. Смотри в комментариях к конкретным классам. Есть док https://docs.python.org/3/howto/descriptor.html

TIP: При обсуждении этих понятий авторы Python пользуются различными терминами. Переопределяющие дескрипторы называют также дескрипторами данных (data descriptor) или принудительными дескрипторами (enforced descriptor). Не переопределяющие дескрипторы известны также под названием дескрипторов без данных (nondata descriptor) или маскирующие дескрипторов (shadowable descriptor).

=== Перезаписывание дескриптора в классе

Независимо от того, является дескриптор переопределяющим или нет, его можно перезаписать путём присваивания на уровне класса.

[source, doctest]
----
>>> Managed.over = 1
>>> Managed.over_no_get = 2
>>> Managed.non_over = 3
>>> obj.over, obj.over_no_get, obj.non_over
(1, 2, 3)
----

=== Советы по использованию дескрипторов

.Для простоты пользуйтесь классом `property`
TIP: Встроенный класс `property` создаёт переопределяющие дескрипторы, в которых реализованы оба метода `\\__set__` и `\\__get__`, даже если вы сами не задавали метод установки. Подразумеваемый по умолчанию метод `\\__set__` возбуждает исключение `AttributeError: can't set attribute`, поэтому свойство -- это простейший способ создать доступный только для чтения атрибут и избежать проблем.

.В дескрипторах только для чтения необходим метод `\\__set__`
TIP: Если вы используете дескрипторный класс для реализации атрибута, доступного только для чтения, то не забывайте реализовывать оба метода `\\__set__` и `\\__get__`, иначе одноимённый атрибут экземпляра замаскирует дескриптор. Метод `\\__set__` атрибута, доступного только для чтения, должен просто возбуждать исключение `AttributeError` с подходящим сообщениемfootnote:[Python не блещет единообразием в таких сообщениях. При попытке изменить атрибут `c.real` комплексного числа выдаётся сообщение `AttributeError: read-only attribute`, а при попытке изменить `c.conjugate` (метод класса `complex`) -- сообщение `AttributeError: 'complex' object attribute 'conjuagate' is read-only.`].

.Проверяющим дескрипторам достаточно одного метода `\\__set__`
TIP: Если дескриптор предназначен только для проверки значений, то метод `\\__set__` должен проверять полученный аргумент `value` и, если он правилен, то устанавливать значение непосредственно в атрибуте `\\__dict__` экземпляра, используя в качестве ключа имя экземпляра дескриптора. Тогда чтение атрибута с таким именем из экземпляра будет производиться максимально быстро, т.к. не требуется наличие метода `\\__get__`.

.Кэширование можно эффективно реализовать при наличии одного лишь `\\__get__`
TIP: Если вы напишете только метод `\\__get__`, то получите непереопределяющий дескриптор. Они полезны, когда требуется выполнить накладные вычисления и кэшировать результат, установив атрибут экземпляра с таким же именем. Одноимённый атрибут экземпляра маскирует дескриптор, поэтому при последующем доступе к этому атрибуту значение будет извлекаться непосредственно из атрибута `\\__dict__` экземпляра в обход метода `\\__get__` дескриптора.

.Неспециальные методы можно замаскировать атрибутами экземпляра
TIP: Поскольку в функциях и методах реализован только метод `\\__get__`, они не перехватывают попытки установить одноименный атрибуты экземпляра, так что после простого присваивания `my_obj.the_method = 7` последующий доступ к `the_method` через данный экземпляр вернёт число 7, хотя на других экземплярах это никак не отразится. Однако на специальные методы это не распространяется. Интерпретатор ищет специальные методы только в самом классе, т.е. `repr(x)` всегда вычисляется как `x.\\__class__.\\__repr__(x)`, так что установка атрибута `\\__repr__`, определённого в `x` не влияет на результат `repr(x)`. По той же причине существование атрибута с именем `\\__getattr__` в экземпляре не испортит обычный алгоритм доступа к атрибутам.

