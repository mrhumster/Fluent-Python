include::./.asciidoctor/.asciidoctorconfig[]

== Глава 18. Применение пакета `asynсio` для организации конкурентной работы

"Предмет конкурентности -- как управляться со многими вещами одновременно.
Предмет параллелизма -- как сделать много вещей одномвременно.
Не одно и то же, но близко.
Первое касается структуры, второе -- выполнения.
Конкурентность предполагает способ решения задач, которая возможно (но не обязательно) поддается распараллеливанию."
-- Роб Пайк, соавтор языка GO.

=== Сравнение потока и сопрограммы

Для сравнения будем писать CLI-спиннер в двух реализациях: потоки и сопрограммы.

.`spinner_thread.py`: анимация текстового индикатора с помощью потока
[source, python]
----
include::{sourcedir}/spinner_thread.py[]
----

.`spinner_asyncio.py`: анимация текстового индикатора с помощью сопрограммы
[source, python]
----
include::{sourcedir}/spinner_asyncio.py[]
----

NOTE: Пришлось немного переделать пример. Книга издана до выпуска Py 3.10. Ранее сопрограммы модуля `asyncio` задавались декоратором `asyncio.croutines`. В свежих версия перешли на синтаксии `async`/`await`. -> (https://docs.python.org/3/library/asyncio.html?highlight=asyncio#module-asyncio[asyncio — Asynchronous I/O])

Сопрограмма по умолчанию защищена от прерывания. Мы должны явно уступить управление, что бы другие части программы могли продолжить работу. Вместо удержания блокировок для синхронизации нескольких потоков мы имеем сопрограммы, которые "синхронизированы" по определению: в каждый момент может работать только одна сопрограмма. А когда мы захотим уступить работу планировщику, то воспользуемся выражением `yield` или `yield from` (или `await` footnote:[Pycharm c Python 3.10 сразу начал говорить об устаревшем методе `@asyncio.coroutine` в пользу использования синтаксиса `async` / `await`]). Именно поэтому прерывания сопрограммы безопасно: по определению сопрограмму можно прервать, только когда она приостановлена в точке `yield`, а, значит, мы сможем выполнить необходимую очистку, перехватив исключение `CancelledError`.

=== `asyncio.Future`: Не блокирует умышленно.

Интерфейс классов `asyncio.Future` и `cuncurrent.futures.Future` в основном совпадают, но реализованы они по-разному и не являются взаимозаменяемыми.

Будущие объекты создаются только в результате планирования какого-то действия. В пакете `asyncio` функция `BaseEventLoop.create_task(...)` принимает сопрограмму, планирует её выполнение и возвращает экземпляр `asyncio.Task`, являющийся так же экземпляром `asyncio.Future`, потому что `Task` подкласс `Future`, который предназначен для обертывания сопрограммы. Это аналогично созданию экземпляров `concurrent.future.Future` посредством вызова `Executor.submit(...)`.




